import * as vscode from 'vscode';
import { WorkItem } from '../models/workItem';

/**
 * Service for integrating with Claude Code extension using VS Code Language Model API
 */
export class ClaudeService {
  private static instance: ClaudeService;
  private static readonly CLAUDE_EXTENSION_ID = 'anthropic.claude-vscode';

  private constructor() {
    // Private constructor for singleton pattern
  }

  public static getInstance(): ClaudeService {
    if (!ClaudeService.instance) {
      ClaudeService.instance = new ClaudeService();
    }
    return ClaudeService.instance;
  }

  /**
   * Check if Claude Code extension is installed
   */
  public isClaudeInstalled(): boolean {
    const claudeExtension = vscode.extensions.getExtension(ClaudeService.CLAUDE_EXTENSION_ID);
    return !!claudeExtension;
  }

  /**
   * Check if Claude is available and the user has access
   */
  public async isClaudeAvailable(): Promise<boolean> {
    if (!this.isClaudeInstalled()) {
      return false;
    }

    try {
      // Check if Language Model API is available
      if (!vscode.lm || !vscode.lm.selectChatModels) {
        console.log('Language Model API not available');
        return false;
      }

      // Try to get available chat models for Claude
      const models = await vscode.lm.selectChatModels({
        vendor: 'anthropic',
        family: 'claude-3.5-sonnet'
      });

      return models.length > 0;
    } catch (error) {
      console.error('Error checking Claude availability:', error);
      return false;
    }
  }

  /**
   * Get the Claude extension object
   */
  private getClaudeExtension(): vscode.Extension<any> | undefined {
    return vscode.extensions.getExtension(ClaudeService.CLAUDE_EXTENSION_ID);
  }

  /**
   * Ensure Claude extension is activated
   */
  private async ensureClaudeActivated(): Promise<boolean> {
    const extension = this.getClaudeExtension();

    if (!extension) {
      return false;
    }

    if (!extension.isActive) {
      try {
        await extension.activate();
        console.log('Claude extension activated');
      } catch (error) {
        console.error('Failed to activate Claude extension:', error);
        return false;
      }
    }

    return true;
  }

  /**
   * Generate a description for a work item using Claude
   */
  public async generateDescription(workItem: WorkItem, existingDescription?: string): Promise<string> {
    // Ensure Claude is available
    if (!await this.isClaudeAvailable()) {
      throw new Error('Claude Code extension is not available. Please install and authenticate the Claude extension.');
    }

    // Activate Claude if needed
    if (!await this.ensureClaudeActivated()) {
      throw new Error('Failed to activate Claude Code extension.');
    }

    const fields = workItem.fields;
    const title = fields['System.Title'];
    const workItemType = fields['System.WorkItemType'];
    const areaPath = fields['System.AreaPath'] || 'Unknown';
    const iterationPath = fields['System.IterationPath'] || 'Unknown';
    const tags = fields['System.Tags'] || 'None';

    // Build context-rich prompt
    const prompt = this.buildPrompt(title, workItemType, areaPath, iterationPath, tags, existingDescription);

    try {
      // Select Claude chat model
      const models = await vscode.lm.selectChatModels({
        vendor: 'anthropic',
        family: 'claude-3.5-sonnet'
      });

      if (models.length === 0) {
        throw new Error('No Claude models available');
      }

      const model = models[0];
      console.log(`Using Claude model: ${model.id} (${model.vendor}/${model.family})`);

      // Create chat messages
      const messages = [
        vscode.LanguageModelChatMessage.User('You are a helpful assistant that writes clear, concise descriptions for Azure DevOps work items. Write 2-3 sentences describing what needs to be done and why. Be specific and actionable.'),
        vscode.LanguageModelChatMessage.User(prompt)
      ];

      // Send request to Claude
      const response = await model.sendRequest(messages, {}, new vscode.CancellationTokenSource().token);

      // Collect the response
      let description = '';
      for await (const chunk of response.text) {
        description += chunk;
      }

      description = description.trim();

      if (!description) {
        throw new Error('No description generated by Claude');
      }

      return description;
    } catch (error: any) {
      console.error('Claude error details:', error);

      if (error.message?.includes('not available')) {
        throw new Error('Claude Code is not available. Please ensure you are signed in to Claude.');
      } else if (error.message?.includes('consent')) {
        throw new Error('User consent required. Please accept the Claude terms in VS Code.');
      } else if (error.message) {
        throw new Error(`Claude API error: ${error.message}`);
      } else {
        throw new Error(`Failed to generate description: ${String(error)}`);
      }
    }
  }

  /**
   * Build the prompt for Claude
   */
  private buildPrompt(
    title: string,
    workItemType: string,
    areaPath: string,
    iterationPath: string,
    tags: string,
    existingDescription?: string
  ): string {
    if (existingDescription && existingDescription.trim() !== '') {
      return `Improve and refine the following description for this Azure DevOps work item:

Type: ${workItemType}
Title: ${title}
Area: ${areaPath}
Iteration: ${iterationPath}
Tags: ${tags}

Current Description:
${existingDescription}

Please improve this description by making it clearer, more concise, and more actionable. Keep it to 2-3 sentences. Maintain the core intent but enhance clarity and specificity.`;
    } else {
      return `Generate a concise 2-3 sentence description for this Azure DevOps work item:

Type: ${workItemType}
Title: ${title}
Area: ${areaPath}
Iteration: ${iterationPath}
Tags: ${tags}

Write a clear description of what needs to be done and why. Be specific and actionable.`;
    }
  }

  /**
   * Generate an implementation plan for a work item using Claude
   */
  public async generateImplementationPlan(workItem: WorkItem): Promise<string> {
    if (!await this.isClaudeAvailable()) {
      throw new Error('Claude Code extension is not available. Please install and authenticate the Claude extension.');
    }

    if (!await this.ensureClaudeActivated()) {
      throw new Error('Failed to activate Claude Code extension.');
    }

    const fields = workItem.fields;
    const title = fields['System.Title'];
    const workItemType = fields['System.WorkItemType'];
    const description = fields['System.Description'] || 'No description provided';
    const areaPath = fields['System.AreaPath'] || 'Unknown';
    const tags = fields['System.Tags'] || 'None';

    const prompt = `You are a senior software engineer helping to plan the implementation of a work item.

Work Item Details:
- Type: ${workItemType}
- Title: ${title}
- Description: ${description}
- Area: ${areaPath}
- Tags: ${tags}

Please create a detailed implementation plan that includes:

1. **Analysis**: Brief analysis of what needs to be done and any considerations
2. **Implementation Steps**: Numbered step-by-step plan with specific technical details
3. **Testing Strategy**: How to test the changes
4. **Potential Challenges**: Any gotchas or things to watch out for
5. **Estimated Complexity**: (Simple/Medium/Complex)

Make the plan actionable and specific. Use markdown formatting.`;

    try {
      const models = await vscode.lm.selectChatModels({
        vendor: 'anthropic',
        family: 'claude-3.5-sonnet'
      });

      if (models.length === 0) {
        throw new Error('No Claude models available');
      }

      const model = models[0];
      const messages = [vscode.LanguageModelChatMessage.User(prompt)];
      const response = await model.sendRequest(messages, {}, new vscode.CancellationTokenSource().token);

      let plan = '';
      for await (const chunk of response.text) {
        plan += chunk;
      }

      plan = plan.trim();

      if (!plan) {
        throw new Error('No plan generated by Claude');
      }

      return plan;
    } catch (error: any) {
      console.error('Claude plan generation error:', error);

      if (error.message?.includes('not available')) {
        throw new Error('Claude Code is not available. Please ensure you are signed in to Claude.');
      } else if (error.message?.includes('consent')) {
        throw new Error('User consent required. Please accept the Claude terms in VS Code.');
      } else if (error.message) {
        throw new Error(`Claude API error: ${error.message}`);
      } else {
        throw new Error(`Failed to generate plan: ${String(error)}`);
      }
    }
  }

  /**
   * Prompt user to install Claude
   */
  public async promptToInstallClaude(): Promise<boolean> {
    const action = await vscode.window.showInformationMessage(
      'Claude Code extension is not installed. Would you like to install it?',
      'Install',
      'Cancel'
    );

    if (action !== 'Install') {
      return false;
    }

    try {
      // Open Claude extension in marketplace
      await vscode.commands.executeCommand(
        'workbench.extensions.installExtension',
        ClaudeService.CLAUDE_EXTENSION_ID
      );

      vscode.window.showInformationMessage(
        'Claude Code extension installation started. Please follow the authentication steps.'
      );

      return true;
    } catch (error) {
      console.error('Failed to install Claude:', error);
      vscode.window.showErrorMessage('Failed to install Claude Code extension.');
      return false;
    }
  }

  /**
   * Show Claude status information
   */
  public async showClaudeStatus(): Promise<void> {
    const installed = this.isClaudeInstalled();
    const available = await this.isClaudeAvailable();

    let message = 'Claude Code Status:\n\n';
    message += `Installed: ${installed ? '✓' : '✗'}\n`;
    message += `Available: ${available ? '✓' : '✗'}\n`;

    if (installed && !available) {
      message += '\nClaude is installed but not available. Please ensure you are signed in to Claude.';
    }

    vscode.window.showInformationMessage(message);
  }
}
